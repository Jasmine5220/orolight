i want to create a react native app wit hflask backend and postgresql db 
i want to create db so a user(doctor) login, captures image in phone, uploads ... flask backend uses that image to predict , shows results on app in mobile and in web as well .... also create admin user which can see all db data an history records .... please tell everything how to create step by step.. use jwt for login/signup 

the model is saved as est_model.sh


i previously created a web flask appp ... i'm giving you app.py for reference  
import os
import numpy as np
import tensorflow as tf
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
from flask import Flask, request, render_template, redirect, url_for
from werkzeug.utils import secure_filename
from tensorflow.keras.applications.inception_resnet_v2 import preprocess_input
from tensorflow.keras import backend as K

app = Flask(__name__)

# Set upload folder
UPLOAD_FOLDER = "static/uploads"
GRADCAM_FOLDER = "static/gradcam"
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER
app.config["GRADCAM_FOLDER"] = GRADCAM_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(GRADCAM_FOLDER, exist_ok=True)

# Load trained model
MODEL_PATH = "model/best_model.h5"
model = load_model(MODEL_PATH)

# Class labels
CLASS_LABELS = ["Non-Cancer", "Cancer"]

def preprocess_image(img_path):
    """Preprocess input image for model prediction."""
    img = image.load_img(img_path, target_size=(299, 299))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)
    return img_array

def make_prediction(img_path):
    """Predict cancer or non-cancer (swapping labels)."""
    img_array = preprocess_image(img_path)
    prediction = model.predict(img_array)[0][0]
    
    class_label = CLASS_LABELS[int(prediction <= 0.5)]  # Flip classification
    confidence = 100 - (prediction) if class_label == "Non-Cancer" else prediction
    
    return class_label, float(confidence / 100)


def generate_gradcam(image_path, model, last_conv_layer_name="conv_7b"):
    # Load the image
    img = tf.keras.preprocessing.image.load_img(image_path, target_size=(299, 299))
    img_array = tf.keras.preprocessing.image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0) / 255.0

    # Create a model that maps input image to conv layer + predictions
    grad_model = tf.keras.models.Model(
        [model.input], [model.get_layer(last_conv_layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        loss = predictions[:, 0]  # Assuming binary classification

    # Compute gradients
    grads = tape.gradient(loss, conv_outputs)

    # Compute pooled gradients
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    # Multiply each channel by its pooled gradient
    conv_outputs = conv_outputs[0]  # Remove batch dimension
    heatmap = tf.reduce_sum(conv_outputs * pooled_grads, axis=-1)

    # Normalize heatmap
    heatmap = np.maximum(heatmap, 0)  # ReLU operation
    heatmap /= np.max(heatmap)  # Normalize to 0-1 range

    # Load the original image
    img = cv2.imread(image_path)
    img = cv2.resize(img, (299, 299))

    # Apply heatmap
    heatmap = cv2.resize(heatmap, (299, 299))
    heatmap = np.uint8(255 * heatmap)
    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)

    # Superimpose the heatmap on the image
    superimposed_img = cv2.addWeighted(img, 0.6, heatmap, 0.4, 0)

    # Save Grad-CAM output
    gradcam_path = image_path.replace(".jpg", "_gradcam.jpg")  # Adjust for other formats
    cv2.imwrite(gradcam_path, superimposed_img)

    return gradcam_path
@app.route("/", methods=["GET", "POST"])
def upload_and_predict():
    if request.method == "POST":
        if "file" not in request.files:
            return redirect(request.url)

        file = request.files["file"]
        if file.filename == "":
            return redirect(request.url)

        if file:
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config["UPLOAD_FOLDER"], filename)
            file.save(filepath)

            # Make prediction
            class_label, confidence = make_prediction(filepath)

            # Generate Grad-CAM (Pass the model)
            gradcam_path = generate_gradcam(filepath, model)

            return render_template(
                "index.html",
                filename=filename,
                prediction=class_label,
                confidence=confidence,
                gradcam=gradcam_path
            )

    return render_template("index.html", filename=None)


@app.route("/uploads/<filename>")
def uploaded_file(filename):
    return url_for("static", filename="uploads/" + filename)

if __name__ == "__main__":
    app.run(debug=True)